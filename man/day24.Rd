% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/day24.R
\name{day24}
\alias{day24}
\alias{f24a}
\alias{f24b}
\alias{example_data_24}
\title{Day 24: Arithmetic Logic Unit}
\usage{
f24a(x)

f24b(x)

example_data_24(example = 1)
}
\arguments{
\item{x}{some data}

\item{example}{Which example data to use (by position or name). Defaults to
1.}
}
\value{
For Part One, \code{f24a(x)} returns .... For Part Two,
\code{f24b(x)} returns ....
}
\description{
\href{https://adventofcode.com/2021/day/24}{Arithmetic Logic Unit}
}
\details{
\strong{Part One}

\href{https://en.wikipedia.org/wiki/Magic_smoke}{Magic smoke} starts leaking
from the submarine\'s \href{https://en.wikipedia.org/wiki/Arithmetic_logic_unit}{arithmetic logic unit} (ALU).
Without the ability to perform basic arithmetic and logic functions, the
submarine can\'t produce cool patterns with its Christmas lights!

It also can\'t navigate. Or run the oxygen system.

Don\'t worry, though - you \emph{probably} have enough oxygen left to give
you enough time to build a new ALU.

The ALU is a four-dimensional processing unit: it has integer variables
\code{w}, \code{x}, \code{y}, and \code{z}. These variables all start with the value \code{0}.
The ALU also supports \emph{six instructions}:
\itemize{
\item \verb{inp a} - Read an input value and write it to variable \code{a}.
\item \verb{add a b} - Add the value of \code{a} to the value of \code{b}, then store the
result in variable \code{a}.
\item \verb{mul a b} - Multiply the value of \code{a} by the value of \code{b}, then
store the result in variable \code{a}.
\item \verb{div a b} - Divide the value of \code{a} by the value of \code{b}, truncate
the result to an integer, then store the result in variable \code{a}.
(Here, \"truncate\" means to round the value toward zero.)
\item \verb{mod a b} - Divide the value of \code{a} by the value of \code{b}, then store
the \emph{remainder} in variable \code{a}. (This is also called the
\href{https://en.wikipedia.org/wiki/Modulo_operation}{modulo} operation.)
\item \verb{eql a b} - If the value of \code{a} and \code{b} are equal, then store the
value \code{1} in variable \code{a}. Otherwise, store the value \code{0} in
variable \code{a}.
}

In all of these instructions, \code{a} and \code{b} are placeholders; \code{a} will
always be the variable where the result of the operation is stored (one
of \code{w}, \code{x}, \code{y}, or \code{z}), while \code{b} can be either a variable or a
number. Numbers can be positive or negative, but will always be
integers.

The ALU has no \emph{jump} instructions; in an ALU program, every instruction
is run exactly once in order from top to bottom. The program halts after
the last instruction has finished executing.

(Program authors should be especially cautious; attempting to execute
\code{div} with \code{b=0} or attempting to execute \code{mod} with \code{a<0} or \code{b<=0}
will cause the program to crash and might even [damage the
ALU]{title="Maybe this is what happened to the last one."}. These
operations are never intended in any serious ALU program.)

For example, here is an ALU program which takes an input number, negates
it, and stores it in \code{x}:\preformatted{inp x
mul x -1
}

Here is an ALU program which takes two input numbers, then sets \code{z} to
\code{1} if the second input number is three times larger than the first
input number, or sets \code{z} to \code{0} otherwise:\preformatted{inp z
inp x
mul z 3
eql z x
}

Here is an ALU program which takes a non-negative integer as input,
converts it into binary, and stores the lowest (1\'s) bit in \code{z}, the
second-lowest (2\'s) bit in \code{y}, the third-lowest (4\'s) bit in \code{x}, and
the fourth-lowest (8\'s) bit in \code{w}:\preformatted{inp w
add z w
mod z 2
div w 2
add y w
mod y 2
div w 2
add x w
mod x 2
div w 2
mod w 2
}

Once you have built a replacement ALU, you can install it in the
submarine, which will immediately resume what it was doing when the ALU
failed: validating the submarine\'s \emph{model number}. To do this, the ALU
will run the MOdel Number Automatic Detector program (MONAD, your puzzle
input).

Submarine model numbers are always \emph{fourteen-digit numbers} consisting
only of digits \code{1} through \code{9}. The digit \code{0} \emph{cannot} appear in a model
number.

When MONAD checks a hypothetical fourteen-digit model number, it uses
fourteen separate \code{inp} instructions, each expecting a \emph{single digit} of
the model number in order of most to least significant. (So, to check
the model number \code{13579246899999}, you would give \code{1} to the first \code{inp}
instruction, \code{3} to the second \code{inp} instruction, \code{5} to the third \code{inp}
instruction, and so on.) This means that when operating MONAD, each
input instruction should only ever be given an integer value of at least
\code{1} and at most \code{9}.

Then, after MONAD has finished running all of its instructions, it will
indicate that the model number was \emph{valid} by leaving a \code{0} in variable
\code{z}. However, if the model number was \emph{invalid}, it will leave some
other non-zero value in \code{z}.

MONAD imposes additional, mysterious restrictions on model numbers, and
legend says the last copy of the MONAD documentation was eaten by a
\href{https://en.wikipedia.org/wiki/Japanese_raccoon_dog}{tanuki}. You\'ll
need to \emph{figure out what MONAD does} some other way.

To enable as many submarine features as possible, find the largest valid
fourteen-digit model number that contains no \code{0} digits. \emph{What is the
largest model number accepted by MONAD?}

\strong{Part Two}

\emph{(Use have to manually add this yourself.)}

\emph{(Try using \code{convert_clipboard_html_to_roxygen_md()})}
}
\examples{
f24a(example_data_24())
f24b()
}
